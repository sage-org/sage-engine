from typing import List, Optional, Set

from sage.query_engine.types import QueryContext, Mappings
from sage.query_engine.iterators.preemptable_iterator import PreemptableIterator, UnaryPreemtableIterator
from sage.query_engine.protobuf.iterators_pb2 import SavedProjectionIterator


class ProjectionIterator(UnaryPreemtableIterator):
    """
    A ProjectionIterator evaluates a SPARQL projection (SELECT) clause in a
    pipeline of iterators.

    This iterator formats each solution mappings generated by the previous
    iterator to keep only the selected variables.

    Parameters
    ----------
    source: PreemptableIterator
        The child of the iterator.
    projection: List[str] - (default = ['*'])
        The set of variables to keep in the solution. If no variables are
        specified, all variables are selected.
    """

    def __init__(
        self, source: PreemptableIterator, projection: List[str] = ["*"]
    ) -> None:
        super(ProjectionIterator, self).__init__("proj", source)
        self._projection = projection

    @property
    def projection(self) -> Set[str]:
        return set(self._projection)

    def next_stage(self, muc: Mappings) -> None:
        """
        Applies the current mappings to the next triple pattern in the pipeline
        of iterators.

        Parameters
        ----------
        muc : Mappings
            Mappings {?v1: ..., ..., ?vk: ...} computed so far.

        Returns
        -------
        None
        """
        self.source.next_stage(muc)

    def __compute_projection__(self, mu: Mappings) -> Mappings:
        """
        Selects the projected variables for the given solution mappings.

        The projection only applies to the variables that start with a "?".
        Variables that start with a "__" are special variables that must be
        sent to the client.

        Parameters
        ----------
        mu: Mappings
            A solution mappings.

        Returns
        -------
        Mappings
            The solution mappings once the projected variables have been
            selected.
        """
        if self._projection[0] == "*":  # keeps all variables
            return mu
        solution = dict()
        for key in mu.keys():
            if key.startswith('__') or key in self.projection:
                solution[key] = mu[key]
        return solution

    async def next(self, context: QueryContext = {}) -> Optional[Mappings]:
        """
        Generates the next item from the iterator, following the iterator
        protocol.

        Parameters
        ----------
        context: QueryContext
            Global variables specific to the execution of the query.

        Returns
        -------
        None | Mappings
            The next item produced by the iterator, or None if all items have
            been produced.

        Raises
        ------
        QuantumExhausted
        """
        mu = await self.source.next(context=context)
        if mu is None:
            return None
        return self.__compute_projection__(mu)

    def pop(self, context: QueryContext = {}) -> Optional[Mappings]:
        """
        Generates the next item from the iterator, following the iterator
        protocol.

        This method does not generate any scan on the database. It is used to
        clear internal data structures such as the buffer of the TOPKIterator.

        Parameters
        ----------
        context: QueryContext
            Global variables specific to the execution of the query.

        Returns
        -------
        None | Mappings
            The next item produced by the iterator, or None if all internal
            data structures are empty.
        """
        mu = self.source.pop(context=context)
        if mu is None:
            return None
        return self.__compute_projection__(mu)

    def save(self) -> SavedProjectionIterator:
        """
        Saves and serializes the iterator as a Protobuf message.

        Returns
        -------
        SavedProjectionIterator
            The state of the ProjectionIterator as a Protobuf message.
        """
        saved_proj = SavedProjectionIterator()

        saved_proj.values.extend(self.projection)

        source_field = f"{self.source.name}_source"
        getattr(saved_proj, source_field).CopyFrom(self.source.save())

        return saved_proj

    def explain(self, depth: int = 0) -> str:
        """
        Returns a textual representation of the pipeline of iterators.

        Parameters
        ----------
        depth: int - (default = 0)
            Indicates the current depth in the pipeline of iterators. It is
            used to return a pretty printed representation.

        Returns
        -------
        str
            Textual representation of the pipeline of iterators.
        """
        prefix = ("| " * depth) + "|"
        description = (
            f"{prefix}\n{prefix}-ProjectionIterator <PV=({self.projection}), "
            f"PROJ=({self.projection})>\n")
        return description + self.source.explain(depth=depth + 1)

    def stringify(self, level: int = 1) -> str:
        """
        Transforms a pipeline of iterators into a SPARQL query.

        Parameters
        ----------
        level: int - (default = 1)
            Indicates the level of nesting of the group. It is used to pretty
            print the SPARQL query.

        Returns
        -------
        str
            A SPARQL query.
        """
        projection = " ".join(self.projection)
        query = f"SELECT {projection}\nWHERE {{\n{self.source.stringify(level=level)}"
        if "ORDER BY" in query:
            temp = query.split("ORDER BY")
            return f"{temp[0]}}} ORDER BY{temp[1]}"
        return query + "}"
