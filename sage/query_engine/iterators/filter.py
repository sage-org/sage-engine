from typing import Optional

from sage.query_engine.types import QueryContext, Mappings
from sage.query_engine.iterators.preemptable_iterator import PreemptableIterator, UnaryPreemtableIterator
from sage.query_engine.protobuf.iterators_pb2 import SavedFilterIterator
from sage.query_engine.expression import Expression


class FilterIterator(UnaryPreemtableIterator):
    """
    A FilterIterator evaluates a FILTER clause in a pipeline of iterators.

    This iterator produces each solution mappings generated by the previous
    iterator that evaluates to True given the filter expression.

    Parameters
    ----------
    source: PreemptableIterator
        The child of the iterator.
    expression: Expression
        The expression of the FILTER clause.
    """

    def __init__(
        self, source: PreemptableIterator, expression: Expression
    ) -> None:
        super(FilterIterator, self).__init__("filter", source)
        self._expression = expression

    @property
    def expression(self) -> Expression:
        return self._expression

    def next_stage(self, muc: Mappings) -> None:
        """
        Applies the current mappings to the next triple pattern in the pipeline
        of iterators.

        Parameters
        ----------
        muc : Mappings
            Mappings {?v1: ..., ..., ?vk: ...} computed so far.

        Returns
        -------
        None

        Raises
        ------
        QuantumExhausted
        """
        self.source.next_stage(muc)

    async def next(self, context: QueryContext = {}) -> Optional[Mappings]:
        """
        Generates the next item from the iterator, following the iterator
        protocol.

        Parameters
        ----------
        context: QueryContext
            Global variables specific to the execution of the query.

        Returns
        -------
        None | Mappings
            The next item produced by the iterator, or None if all items have
            been produced.
        """
        while True:
            try:
                mu = await self.source.next(context=context)
                if mu is None or self.expression.eval(mu):
                    return mu
            except Exception:  # if an error occurs, the FILTER is evaluated as False
                continue

    def pop(self, context: QueryContext = {}) -> Optional[Mappings]:
        """
        Generates the next item from the iterator, following the iterator
        protocol.

        This method does not generate any scan on the database. It is used to
        clear internal data structures such as the buffer of the TOPKIterator.

        Parameters
        ----------
        context: QueryContext
            Global variables specific to the execution of the query.

        Returns
        -------
        None | Mappings
            The next item produced by the iterator, or None if all internal
            data structures are empty.
        """
        return None

    def save(self) -> SavedFilterIterator:
        """
        Saves and serializes the iterator as a Protobuf message.

        Returns
        -------
        SavedFilterIterator
            The state of the FilterIterator as a Protobuf message.
        """
        saved_filter = SavedFilterIterator()

        source_field = f"{self.source.name}_source"
        getattr(saved_filter, source_field).CopyFrom(self.source.save())

        saved_filter.expression = self.expression.stringify()

        return saved_filter

    def explain(self, depth: int = 0) -> str:
        """
        Returns a textual representation of the pipeline of iterators.

        Parameters
        ----------
        depth: int - (default = 0)
            Indicates the current depth in the pipeline of iterators. It is
            used to return a pretty printed representation.

        Returns
        -------
        str
            Textual representation of the pipeline of iterators.
        """
        prefix = ("| " * depth) + "|"
        description = (
            f"{prefix}\n{prefix}-FilterIterator <PV=({self.vars}), "
            f"EXPR=({self.expression.stringify()})>\n")
        return description + self.source.explain(depth=depth + 1)

    def stringify(self, level: int = 1) -> str:
        """
        Transforms a pipeline of iterators into a SPARQL query.

        Parameters
        ----------
        level: int - (default = 1)
            Indicates the level of nesting of the group. It is used to pretty
            print the SPARQL query.

        Returns
        -------
        str
            A SPARQL query.
        """
        prefix = " " * 2 * level
        filter = f"{prefix}FILTER ({self.expression.stringify()}) .\n"
        return self.source.stringify(level=level) + filter
