from typing import Optional

from sage.query_engine.types import QueryContext, Mappings
from sage.query_engine.iterators.preemptable_iterator import PreemptableIterator, BinaryPreemtableIterator
from sage.query_engine.protobuf.iterators_pb2 import SavedIndexJoinIterator
from sage.query_engine.protobuf.utils import pyDict_to_protoDict


class IndexJoinIterator(BinaryPreemtableIterator):
    """
    A IndexJoinIterator implements an Index Loop Join in a pipeline of iterators.

    Parameters
    ----------
    left: PreemptableIterator
        The left child of the iterator.
    right: PreemptableIterator
        The right child of the iterator.
    muc: None | Mappings - (default = None)
        The current state of variables.
    """

    def __init__(
        self, left: PreemptableIterator, right: PreemptableIterator,
        muc: Optional[Mappings] = None
    ) -> None:
        super(IndexJoinIterator, self).__init__("join", left, right)
        self._muc = muc

    def next_stage(self, muc: Mappings) -> None:
        """
        Applies the current mappings to the next triple pattern in the pipeline
        of iterators.

        Parameters
        ----------
        muc : Mappings
            Mappings {?v1: ..., ..., ?vk: ...} computed so far.

        Returns
        -------
        None
        """
        self._muc = None
        self.left.next_stage(muc)

    async def next(self, context: QueryContext = {}) -> Optional[Mappings]:
        """
        Generates the next item from the iterator, following the iterator
        protocol.

        Solutions generated by the left iterator are applied to the right
        iterator. Before asking the left iterator to generate the next solution
        mappings, the right iterator is fully consumed.

        Parameters
        ----------
        context: QueryContext
            Global variables specific to the execution of the query.

        Returns
        -------
        None | Mappings
            The next item produced by the iterator, or None if all items have
            been produced.

        Raises
        ------
        QuantumExhausted
        """
        while True:
            if self._muc is None:
                self._muc = await self.left.next(context=context)
                if self._muc is None:  # the left iterator has been fully consumed, exit the loop
                    return None
                self.right.next_stage(self._muc)  # muc is applied to the right iterator
            else:
                mu = await self.right.next(context=context)
                if mu is not None:
                    return mu
                self._muc = None  # to ask the left iterator to generate the next solution mappings

    def pop(self, context: QueryContext = {}) -> Optional[Mappings]:
        """
        Generates the next item from the iterator, following the iterator
        protocol.

        This method does not generate any scan on the database. It is used to
        clear internal data structures such as the buffer of the TOPKIterator.

        Parameters
        ----------
        context: QueryContext
            Global variables specific to the execution of the query.

        Returns
        -------
        None | Mappings
            The next item produced by the iterator, or None if all internal
            data structures are empty.
        """
        return None

    def save(self) -> SavedIndexJoinIterator:
        """
        Saves and serializes the iterator as a Protobuf message.

        Returns
        -------
        SavedIndexJoinIterator
            The state of the IndexJoinIterator as a Protobuf message.
        """
        saved_join = SavedIndexJoinIterator()

        left_field = f"{self.left.name}_left"
        getattr(saved_join, left_field).CopyFrom(self.left.save())

        right_field = f"{self.right.name}_right"
        getattr(saved_join, right_field).CopyFrom(self.right.save())

        if self._muc is not None:
            pyDict_to_protoDict(self._muc, saved_join.muc)

        return saved_join

    def explain(self, depth: int = 0) -> str:
        """
        Returns a textual representation of the pipeline of iterators.

        Parameters
        ----------
        depth: int - (default = 0)
            Indicates the current depth in the pipeline of iterators. It is
            used to return a pretty printed representation.

        Returns
        -------
        str
            Textual representation of the pipeline of iterators.
        """
        prefix = ("| " * depth) + "|"
        description = f"{prefix}\n{prefix}-IndexJoinIterator <PV=({self.vars})>\n"
        description += self.left.explain(depth=depth + 1)
        description += self.right.explain(depth=depth + 1)
        return description

    def stringify(self, level: int = 1) -> str:
        """
        Transforms a pipeline of iterators into a SPARQL query.

        Parameters
        ----------
        level: int - (default = 1)
            Indicates the level of nesting of the group. It is used to pretty
            print the SPARQL query.

        Returns
        -------
        str
            A SPARQL query.
        """
        return self.left.stringify(level=level) + self.right.stringify(level=level)
