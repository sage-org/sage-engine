from typing import Optional

from sage.query_engine.types import QueryContext, Mappings
from sage.query_engine.iterators.preemptable_iterator import PreemptableIterator, UnaryPreemtableIterator
from sage.query_engine.protobuf.iterators_pb2 import SavedLimitIterator


class LimitIterator(UnaryPreemtableIterator):
    """
    A LimitIterator evaluates a SPARQL LIMIT k operator in a pipeline of
    iterators.

    This iterator produces the first k solutions generated by the previous
    iterator.

    Parameters
    ----------
    source: PreemptableIterator
        The child of the iterator.
    limit: int
        The number of solutions to produce.

    produced: int
        The number of solutions produced so far.
    """

    def __init__(
        self, source: PreemptableIterator, limit: int, produced: int = 0
    ) -> None:
        super(LimitIterator, self).__init__("limit", source)
        self._limit = limit
        self._produced = produced

    @property
    def limit(self) -> int:
        return self._limit

    def next_stage(self, muc: Mappings) -> None:
        """
        Applies the current mappings to the next triple pattern in the pipeline
        of iterators.

        Parameters
        ----------
        muc : Mappings
            Mappings {?v1: ..., ..., ?vk: ...} computed so far.

        Returns
        -------
        None
        """
        self.source.next_stage(muc)

    async def next(self, context: QueryContext = {}) -> Optional[Mappings]:
        """
        Generates the next item from the iterator, following the iterator
        protocol.

        Parameters
        ----------
        context: QueryContext
            Global variables specific to the execution of the query.

        Returns
        -------
        None | Mappings
            The next item produced by the iterator, or None if all items have
            been produced.

        Raises
        ------
        QuantumExhausted
        """
        if self._produced < self.limit:
            mu = await self.source.next(context=context)
            if mu is None:
                return None
            self._produced += 1
            return mu
        return None

    def pop(self, context: QueryContext = {}) -> Optional[Mappings]:
        """
        Generates the next item from the iterator, following the iterator
        protocol.

        This method does not generate any scan on the database. It is used to
        clear internal data structures such as the buffer of the TOPKIterator.

        Parameters
        ----------
        context: QueryContext
            Global variables specific to the execution of the query.

        Returns
        -------
        None | Mappings
            The next item produced by the iterator, or None if all internal
            data structures are empty.
        """
        if self._produced < self.limit:
            mu = self.source.pop(context=context)
            if mu is None:
                return None
            self._produced += 1
            return mu
        return None

    def save(self) -> SavedLimitIterator:
        """
        Saves and serializes the iterator as a Protobuf message.

        Returns
        -------
        SavedLimitIterator
            The state of the LimitIterator as Protobuf message.
        """
        saved_limit = SavedLimitIterator()

        source_field = f"{self.source.name}_source"
        getattr(saved_limit, source_field).CopyFrom(self.source.save())

        saved_limit.limit = self.limit
        saved_limit.produced = self._produced

        return saved_limit

    def explain(self, depth: int = 0) -> str:
        """
        Returns a textual representation of the pipeline of iterators.

        Parameters
        ----------
        depth: int - (default = 0)
            Indicates the current depth in the pipeline of iterators. It is
            used to return a pretty printed representation.

        Returns
        -------
        str
            Textual representation of the pipeline of iterators.
        """
        prefix = ("| " * depth) + "|"
        description = (
            f"{prefix}\n{prefix}-LimitIterator <PV=({self.vars}), "
            f"LIMIT=({self.limit})>\n")
        return description + self.source.explain(depth=depth + 1)

    def stringify(self, level: int = 1) -> str:
        """
        Transforms a pipeline of iterators into a SPARQL query.

        Parameters
        ----------
        level: int - (default = 1)
            Indicates the level of nesting of the group. It is used to pretty
            print the SPARQL query.

        Returns
        -------
        str
            A SPARQL query.
        """
        limit = f"LIMIT {self.limit}"
        return self.source.stringify(level=level) + limit
